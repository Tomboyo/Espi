# Espi

Espi is a proof-of-concept declarative application framework that uses configuration and attributes to lift normal, unadultered functions into cron jobs, RabbitMQ messasge handlers, or other processes.

## An Example: Timeouts 

(To run this example, see examples/timeout.)

Suppose we have two functions that we want to invoke on a schedule. To configure them to run every _n_ milliseconds, we use the `Espi.Timeout` component like so:

```elixir
defmodule Example.Timeouts do
  use Espi
  alias Espi.Timeout
  require Logger

  @component {Timeout, schedule: 1_000}
  def fn1(), do: Logger.info("Function 1 called!")

  @component {Timeout, schedule: 1_500}
  def fn2(), do: Logger.info("Function 2 called")
end
```

This does not alter the functions in any way. When we `use Espi`, all the macro does is keep track of which functions have been registered as callbacks. When we launch our application, Espi will use that information to start our component processes. This is how we start our application:

```elixir
defmodule Example.App do
  use Application

  def start(_type, _args) do
    children = [
      # Scan for components defined in our Example.* modules.
      {Espi, [app: :timeout, namespace: Example]}
    ]

    Supervisor.start_link(children, strategy: :one_for_one)
  end
end
```

We configured Espi to search only modules loaded by our `:example` application and only under the `Example` namespace (which lets us filter out or add in components from other libraries). When our aplication starts, we see logging statements generated by GenServer processes calling our functions as callbacks!
